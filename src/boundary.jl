
const Dirichlet=0
const Neumann=-1

#################################################################################################################

## struct Boundary and related operators on it

#################################################################################################################


@doc raw"""
    Plane{T}
    provides a 'base' vector and a 'normal' vector of type 'T' to describe a plane. 
    BC=Dirichlet or BC=Neumann indicate Dirichlet- resp. Neumann- boundary condition on the plane.
    BC='any positive number' indicates periodic boundary conditions with the complementary plane given by the index BC
"""

struct Plane
    base::Vector{Float64}
    normal::Vector{Float64}
    function Plane(b,n) 
        return new(b,n)
    end
end




#################################################################################################################

## struct Boundary and related operators on it

#################################################################################################################

"""
    Boundary

provides the data structure for boundaries of VoronoiGeometry. Its most important feature is the vector
    
    planes::Vector{Plane}

which stores every flat part of the boundary as

    struct Plane
        base::Vector{Float64} # base of the plane
        normal::Vector{Float64} # outer normal of the domain on this plane
    end
"""
struct Boundary{T}
    planes::Vector{T}
end
function Boundary(_planes::Vector)
    return Boundary{Plane}(_planes)
end

"""
    Boundary(planes...)

is the constructor for Boundaries. planes... is a list of planes generated by either one of the following functions:

    BC_Dirichlet(b,n)
    BC_Neumann(b,n)

generating Dirichlet resp. Neumann boundaries with base `b` and normal `n`.

    BC_Periodic(base1,base2,normal1)

generating two periodic boundaries with `base1` and `normal1`  resp. with `base2` and `normal = -normal1` 

"""
function Boundary(planes...)
    newplanes=Vector{Plane}(undef,length(planes))
    count=1
    for p in planes
            newplanes[count]=p
            count+=1
    end
    return Boundary(newplanes)
end

function Boundary()
    return Boundary(Plane[])
end

import Base.in

####################### GEOMETRIC OPERATIONS ######################################################################

function reflect(node,boundary::Boundary,plane;indeces=nothing)
    _plane=typeof(indeces)==Nothing ? boundary.planes[plane] : boundary.planes[indeces[plane]]
    normal=_plane.normal
    base=_plane.base
    return node+normal .*(2*dot(normal,base.-node))    
end



@doc raw"""
    intersect(P::Plane,x_0,v)

    calculates the scalar solution t to the problem
    (y-P.base)*P.normal=0  ,  x_0+t*v=y
    eg: (P.base-x_0)*P.normal == t v*P.normal 

"""
function intersect(P::Plane,x_0,v)
    return dot(P.base-x_0,P.normal)/dot(v,P.normal)
end

@doc raw"""
    intersect(B::Boundary,x_0,v)

    calculates intersect(P,x_0,v) for every plane P in B and returns (i,t), the index 'i' of the minimal result 
    as well as the minimal result 't'

"""
function intersect(B::Boundary,x_0,v,condition=(x->true))
    index=0::Int64
    t=Inf64::Float64
    for i in 1:(length(B.planes))
        if !condition(i) continue end
        new_t=intersect(B.planes[i],x_0,v)
        if 0<new_t<t 
            t=new_t
            index=i
        end
    end
    return index,t
end

@doc raw"""
    intersections(B::Boundary,x_0,v)

calculates for every plane p_i of B the value t_i with x_0+t_i*v_ in p_i . results will store a sorted list of t_i and indeces stores the corresponding list of i. 
The return value is the entry i of indeces such that x_0 +0.5*(t_i + t_(i+1)) in B
"""
function intersections!(B::Boundary,x_0,v; results=zeros(Float64,length(B.planes)), indeces=collect(1:length(B.planes)), condition=(x->true))
    sort!(indeces)
    for i in 1:(length(B.planes))
        if !condition(B.planes[i].BC) continue end
        results[i]=intersect(B.planes[i],x_0,v)
    end
    quicksort!(results,indeces,indeces)
    found=0
    r=results
    for i in 1:(length(results)-1)
        if (results[i]>-Inf && results[i+1]<Inf)
            point=x_0+0.5*(r[i]+r[i+1])*v
            if point in B 
                found=i 
                break
            end  
        end
    end
    return found
end

@doc raw"""
    intersect(B::Boundary,v::boundary_vertex)
    returns the couple 'i','t' such that the line v.base+t*v.direction lies in B.planes[i]
    'i' is such that 't' is the minimal positive value, i.e. B.planes[i] is actually 
    the true part of the boundary that is hit by 'v'
"""
function intersect(B::Boundary,v::boundary_vertex,condition=(x->true))
    return intersect(B,v.base,v.direction,condition)
end

function in(x,B::Boundary)
    l=length(B.planes)
    l==0 && return true
    for i in 1:l
        plane=B.planes[i]
        if dot(plane.base-x,plane.normal)<0 return false end
    end
    return true
end

function adjust_boundary_vertex(x,B::Boundary,sig,lmesh,lsig=length(sig),tolerance=1.0E-10)
    x2 = x
    for i in lsig:-1:1
        sig[i]<=lmesh && break
        plane=B.planes[sig[i]-lmesh]
        my_prod = dot(plane.base-x2,plane.normal)
        if my_prod<0 && my_prod>-tolerance 
            x2 = x2 + 2*my_prod*plane.normal 
        end
    end
    return x2
end

function show_in(x,B::Boundary)
    l=length(B.planes)
    l==0 && return true
    for i in 1:l
        plane=B.planes[i]
        if dot(plane.base-x,plane.normal)<0 
            println(i,": ",plane.base-x," , ",plane.normal," , ",dot(plane.base-x,plane.normal))
            return false 
        end
    end
    return true
end

function project(x,B::Boundary)
    x2=x
    l=length(B.planes)
    l==0 && return x
    for i in 1:l
        plane=B.planes[i]
        d=dot(plane.base-x,plane.normal)
        if d<0 
            x2=x2+d*plane.normal 
        end
    end
    return x2
end

function length(b::Boundary)
    return length(b.planes)
end

function push!(boundary::Boundary,plane::Plane)
    push!(boundary.planes,plane)
end


###################### GENERATING CUBES ###############################################

center_cube(dim,size)=cuboid(dim,dimensions=size*ones(Float64,dim),offset=-0.5*size*ones(Float64,dim))

"""
    cuboid(dim;dimensions=ones(Float64,dim),offset=zeros(Float64,dim))

or simply `cuboid(dim)` generates a cube of type `Boundary`. 
- dim : This is the dimension of the cuboid
- dimensions : provides the size of the cuboid in each dimension
- offset : shifts the cube in space  

A particular application is the following method provided by HighVoronoi.

    center_cube(dim,size) = cuboid(dim,dimensions=size*ones(Float64,dim),offset=-0.5*size*ones(Float64,dim))

Relying on `cuboid(...)` it generates a cube with center `0` and edge length `size`.
"""
function cuboid(dim;dimensions=ones(Float64,dim),offset=zeros(Float64,dim))
    planes=Vector{Plane}(undef,2*dim)
    unit=zeros(Float64,dim)
    _zeros=zeros(Float64,dim)
    periodic=[]
    neumann=[]
    for i in 1:dim
        unit.*=0
        unit[i]=1
        if i in periodic
            planes[(2*i)-1]=Plane(offset.+dimensions[i] .*unit,copy(unit))
            planes[2*i]=Plane(copy(offset),(-1).*unit)
            continue
        end
            planes[(2*i)-1]=Plane(offset.+dimensions[i].*unit,copy(unit))
            planes[2*i]=Plane(copy(offset),(-1).*unit)
    end
    return Boundary(planes)
end


